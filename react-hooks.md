- [Теория](#Теория)
- [Проблемы](#Проблемы)
- [useState](#useState)
- [useEffect](#useEffect)
- [useLayoutEffect](#useLayoutEffect)
- [useCallback](#useCallback)
- [useMemo](#useMemo)
- [useRef](#useRef)
- [useContext](#useContext)
- [Пользовательские_хуки](#Пользовательские_хуки)
- [Хуки изнутри](#Хуки_изнутри)


## Теория

React hooks появились в версии React 16.8, они позволяют использовать состояние в функциональном компоненте.
Хуки польностью обратно совместимы - можно писать как на классах, так и на хуках. Согласно документации - при использоовании хуков, приложение не становится медленнее. К примеру хуки требуют меньше затрат, чем при создании классов, например вызов конструктора и binding обработчиков. Проект на хуках имеет менее глубокое дерево компонентов, а чем меньше дерево, тем меньше работы должен выполнять React.

    Хуки — это функции, с помощью которых вы можете «подцепиться» к состоянию и методам жизненного цикла React из функциональных компонентов.
    Хуки не работают внутри классов — они дают вам возможность использовать React без классов. Именно из-за свойства "прицепиться" хук и называется хуком.

### Проблемы

- переиспользование логики - в React и без хуков можно переиспользовать логику, для этого у него есть два патерна
  `рендер-пропсы` (render props) и `компоненты высшего порядка` (HOC), эти патерны заставляют изменять структуру компонента, раздувая его
  Но самый яркий минус этих подходов - это огромное кол-во оберток, провайдеров, консумеров в дев тулзах

С помощью хуков можно извлекать логику из компонента, тестировать и переиспользовать, не изменяя сам компонент

- вторая проблема - это размазанная логика по методам жц (жизненный цикл)
  чаще всего подписки и отписки от методов происходят в componentDidMount/componentWillUnmount, так же нужно обновлять состояние в componentDidUpdate, в итоге такой код становится сложнее воспринимать и поддерживать

Хуки позволяют еффективно разбить логику на разные части (используя пользовательские хуки)

- классы более сложны в понимании - для работы с классом, нужно понимать, как работает конекст (this), наследование, нужно помнить
  о привязке контекста к обработчикам (классы плохо минифицируются и ломают hot reloading).
  Но у хуков так же есть недостаток, после жц может быть сложным их изучение, так же нужно понимать, как работают замыкания.

### Правила использования хуков

    ✅ Вызывать хуки из функционального компонента React.
    ✅ Нельзя вызывать хуки по условию (если нужно условие - переместить его внутрь хука).
    ✅ Желательно называть хуки с приставки use.

Для упрощения работы есть плагин [eslint-plugin-react-hooks](https://www.npmjs.com/package/eslint-plugin-react-hooks), который следит за тем, что бы разработчики соблюдали правила.

## Обзор хуков

### useState

Один из самых простых, на первый взгляд хуков `useState`.
Хук `useState` принимает один аргумент - начальное состояние (оно может быть абсолютно любым значением) и возвращает массив, первый елемент которого - текущее состояние (обьявляет переменную `count`), а второй - колбек (React гарантирует, что ссылка на него будет ВСЕГДА одна и таже), с помощью которого нужно обновлять состояние (похож на классовый setState) - деструктуризация. Считается хорошей практикой данный обработчик называть с приставкой `set`. Обычно считается, что после выполнения функции - ее локальные переменные удаляются вместе с ней, но тут все не так, потому что React сам следит за этим и сохраняет результаты для каждого компонента отдельно. В одном компоненте можно использовать не ограниченное кол-во хуков. После каждого вызова `setState` React по новой вызывает (обновляет) компонент и каждое следующее обновление уже имеет новое (собственное )состояние, которое является константой внутри нашей функции. Это значит, что ссылка на значение не выполняет никакой привязки данных.

```js
function Foo() {
  const [count, setCount] = useState(0);
}
```

Что бы прочитать состояние, достаточно просто обратится к переменной напрямую (React не выполняет никакие привязки и подписки для этого).

```js
function Foo() {
  const [count, setCount] = useState(0);

  return <p>Текущее значение: {count}</p>;
}
```

Что бы изменить состояние достаточно просто вызвать колбек и передать в него новое состояние. Колбек может принимать или новое значение состояния - или функцию, в которой аргументом будет текущее состояние (это полезно делать - например в еффектах, что бы не было лишних значений в массиве `deps` или что бы обновилять состояние из ребенка без передачи лишнего пропса)

```js
function Foo() {
  const [count, setCount] = useState(0);

  return (
    <>
      <p>Текущее значение: {count}</p>
      <button onClick={() => setCount(count + 1)}>setCount</button>
      <button onClick={(state) => setCount(state + 1)}>setCount</button>
    </>
  );
}
```

Стоит обратить внимание, на замыкания, сколько бы раз на вызвали `setCount` - после вызова `handleShowCount` - в консоль будет выведено последнее значения состояния. Такое поведение обьясняется тем, что каждый рендер в React "видит" свое собственное - изолированное состояние. При вызове `setCount` рендер возвращает "новую" версию функции `handleShowCount`, которая ссылается на `count` из текущего рендера.

      Внутри одного рендера - состояние и свойства всега остаются неизменными.

```js
function Foo() {
  const [count, setCount] = useState(0);

  function handleShowCount() {
    setTimeout(() => {
      console.log(count);
    }, 3000);
  }

  return (
    <>
      <p>Текущее значение: {count}</p>
      <button onClick={() => setCount(count + 1)}>setCount</button>
      <button onClick={handleShowCount}>handleShowCount</button>
    </>
  );
}
```

Как мы узнали ранее, в компоненте может быть n- вызовов хуков, каждый хук будет со своим уникальным состоянием и обработчиком. Данные обработчики можно использвать как напрямую, так и в других обработчиках или передавать дочерним елементам (для изменения состояния из ребенка). Так же в состояние можно передать пропс или колбек, React не будет повторно вызывать функцию переданную ка начальное состояние, ее он вызывает 1 раз при создании компонента.

```js
function Foo() {
  const [age, setAge] = useState(() => 0);

  return (
    <>
      <p>{age}</p>
    </>
  );
}
```

Пример передачи обработчика дочернему компоненту.

```js
function Foo() {
  const [age, setAge] = useState(0);

  return (
    <>
      <p>{age}</p>
      <Children setAge={setAge} />
    </>
  );
}

function Children({ setAge }) {
  return (
    <>
      <button onClick={() => setAge((state) => state + 1)}>
        Обновить возвраст из дочернего компонента
      </button>
    </>
  );
}
```

Множество вызовов хука с различным состоянием.

```js
function Foo() {
  const [age, setAge] = useState(0);
  const [name, setName] = useState("Bogdan");
  const [friends, setFriends] = useState([
    { name: "Alexandr" },
    { name: "Dmitry" },
  ]);

  const removeFriendByName = (friendName) => {
    setFriends((state) => state.filter((friend) => friend.name !== friendName));
  };

  return (
    <>
      <p>Количество друзей: {friends.length}</p>
      <button onClick={() => setAge(23)}>setAge</button>
      <button onClick={() => removeFriendByName("Alexandr")}>
        Удалить друга
      </button>
      <input value={name} onChange={({ target }) => setName(target.value)} />
    </>
  );
}
```

В примере выше - хочу обратить внимание на функцию `removeFriendByName`. React всегда смотрит на равенство ссылок, это значит, что из обработчика переданного в `setState` - нужно всегда возвращать новое значение, а не мутировать старое.
Метод `splice` в функции `removeFriendByNameWithMutation` - "мутирует" состояние, это значит, что он оставляет старую ссылку и вырезает елемент у исходного состояния. Если вызвать эту функцию, то React ничего не сделает, ведь он считает, что ссылка осталась старой и не будет выполнять обновление компонента, но состояние БУДЕТ изменено по ссылке. Это легко проверить, достаточно после вызова `removeFriendByNameWithMutation` вызвать `removeFriendByName`, тогда реакт запустит обновление компонента и на екране будет цифра 0. Тут так же стоит сомтреть на то, что возвращается из обработчика, в примере возвращаем не новое состояние, а результат выполнения функции `splice`.

```js
function Foo() {
  const [friends, setFriends] = useState([
    { name: "Alexandr" },
    { name: "Dmitry" },
  ]);

  const removeFriendByName = (friendName) => {
    setFriends((state) => state.filter((friend) => friend.name !== friendName));
  };

  const removeFriendByNameWithMutation = (friendName) => {
    setFriends((state) => {
      const index = state.findIndex((item) => (item.name = friendName));

      state.splice(index, 1);

      // return state.splice(index, 1); // вернет результат выполнения splice

      return state; // вернет мутированное состояние
    });
  };

  return (
    <>
      <p>Количество друзей: {friends.length}</p>
      <button onClick={() => removeFriendByName("Dmitry")}>
        Удалить друга
      </button>
      <button onClick={() => removeFriendByNameWithMutation("Alexandr")}>
        Удалить друга (мутация)
      </button>
    </>
  );
}
```

Так же React довольно "умный", он умеет обьединять вызовы (в рамках одного обработчика) `setState` в один апдейт - `batch`, стоит заметить, что асинхронные вызовы он не сможет сгрупировать.

В примере `Example1` результат вызова `handleUpdateState` будет 100, при этом обновление будет выполнено всего 1 раз (а не 3). Такой результат получился, потому что при первом вызове `setState` - React сохранил его состояние у себя `0 => 0 + 10`, результат 10. Дальше присходит второй вызов, но так, как обновления компонента еще не было, во втором вызове будет старое значение состояния и оно перезатрет предыдущее `() => 0 + 10`, рузультат 10. И финальный вызов так же ссылается на старое состояние `(0 + 100)` и в итоге он перезатрет предыдущий результат и React произведет обновление компонента, вернув последний результат 100.
Во втором примере `handleUpdateAsyncState` - асинхронная функция, при ее вызове - реакт сделает 3 различных обновления, логика будет такой же как и в первом примере и ответ будет 100. Но у React есть способо обойти это ограничение и сделать еденичный апдейт для этого есть функция `ReactDOM.unstable_batchedUpdates`. Вызов функции `handleUpdateAsyncStateWithBatched` вернет одно обновление компонента.

```js
function Example1() {
  const [state, setState] = useState(0);

  const handleUpdateState = () => {
    setState((state) => state + 10);
    setState(() => state + 10);
    setState(state + 100);
  };

  const handleUpdateAsyncState = () => {
    setTimeout(() => {
      setState((state) => state + 10);
      setState(() => state + 10);
      setState(state + 100);
    }, 500);
  };

  const handleUpdateAsyncStateWithBatched = () => {
    setTimeout(() => {
      ReactDOM.unstable_batchedUpdates(() => {
        setState((state) => state + 10);
        setState(() => state + 10);
        setState(state + 100);
      });
    }, 500);
  };

  console.log("update");

  return (
    <>
      <button onClick={handleUpdateState}>Обновить</button>
      <button onClick={handleUpdateAsyncState}>Обновить асинхронно</button>
    </>
  );
}
```

### Хук состояния useReducer

```js
const reducer = (state, payload) => {
  switch (payload.type) {
    case "Name":
      return {
        ...state,
        name: payload.params,
      };
    case "Age":
      return {
        ...state,
        age: payload.params,
      };
    default:
      return state;
  }
};

const initializer = (state) => {
  return {
    ...state,
    name: "some name",
  };
};

export default function App() {
  const [state, dispatch] = useReducer(
    reducer,
    { age: 0, name: "" },
    initializer
  );

  return (
    <div>
      <p>name: {state.name}</p>
      <p>age: {state.age}</p>
      <hr />
      <button onClick={() => dispatch({ type: "Name", params: "Bogdan" })}>
        обновить имя
      </button>
      <button onClick={() => dispatch({ type: "Age", params: 23 })}>
        обновить возраст
      </button>
    </div>
  );
}
```

[Хук](https://codesandbox.io/s/usereducer-hjy9u?file=/src/App.js) принимает три аргумента:

- reducer - функция, которая описывает, как обновить состояние
- state - начальное состояние
- initializer - функция, которая передает свой результат в начальное состояние (ленивая инициализация)

Воззвращает текущее состояние и функцию, что бы его обновить. Хук использовать предпочтительнее, когда в одном компоненте много вызовов `useState`, что бы вынести все в редюсер и очистить компонент. Или же, когда следующее состояние зависит от предыдущего. Так же его удобно использовать в сязке с `useEffect`, что бы не делать лишних вызовов еффекта, достаточно передать только `dispatch` в зависимости. Как и с `useState` - React гарантирует, что ссылка на функию `dispatch` всегда будет не изменна. Так же, если возврощать старое состояние, React не будет делать ререндеры.

```js
const [name, setName] = useState("");
const [names, setNames] = useState([]);

useEffect(() => {
  if (name) {
    setNames(names.filter((n) => n !== name)); // для помера сделано так
  }
}, [name, names]);

// пример с useReducer

const [state, dispatch] = useReducer(reducer, { name: "", names: [] });

useEffect(() => {
  dispatch({ type: "Update names" });
}, [dispatch]);
```

### useEffect

Хук дает возможность выполнять `side effects (побочные эффекты)` в функциональном компоненте. Побочные эффекты это запросы, изменение DOM, подписки. Данный хук React вызывает `асинхронно`, после того, как применил все изменения в DOM (commit phase), не смотря на то, что еффект откладывается, он гарантированно сработает перед следующей визуализацией, потому что React всегдасбрасывает еффекты предыдущего рендера. Стоит заметить, что порядок вызова хуков соответствует порядку написания. Что бы лучше понимать еффекты, не нужно смотреть на них как на методы жц, это будет сбивать с толку.

Как же `useEffect` "видит" новую переменную `count` ? Все просто, он так же как и любой другой обрабочик - на каждый рендер "видит" свою собственную переменую, это работает до тех пор, пока мы не забыли добавить `зависимость` в еффект, таким образом еффект предоставлен разными функциями при каждом рендере - и каждая функция еффекта "видит" состояние конкретного рендера. React запоминает функцию еффекта и запускает ее после всех изменений в DOM.

    Грубым примером можно представить еффект как часть `результата` рендера.

```js
function Foo() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log(count);
  });

  return (
    <>
      <button onClick={() => setCount(count + 1)}>setCount</button>
    </>
  );
}
```

Каждый вызов `setCount` запускает свой еффект, который запоминает текущее состояние (замыкание). Но это не работает с изменением исходного состояния по ссылке. (стоит заметить, что это не является ошибкой, иногда такое поведение просто необходимо)

```js
function Foo() {
  const [count, setCount] = useState(0);

  const ref = React.useRef(null);

  useEffect(() => {
    setTimeout(() => {
      console.log(count); // после каждого клика новое значение
    }, 3000);
  });

  useEffect(() => {
    ref.current = count;
    setTimeout(() => {
      console.log(ref.current); // после изменения состояния в консоли будут цифры последнего изменения
    }, 3000);
  });

  return (
    <>
      <button onClick={() => setCount(count + 1)}>setCount</button>
    </>
  );
}
```

Вернемся к подпискам и отпискам. Можно подумать, что при обновлении React сделает очистку для текущего `id`, но это не так, как мы узнали ранее, еффект вызывается `после отрисовки DOM`, это значит, что произойдет подписка с `id = 1`. После обновления id - вызывается еффект, но он сначала выполняет `отписку` (колбек, который возвращается из еффекта) c `id = 1` (предыдущее значение) и только после этого выполняет следующий еффект и подписку с новым значением. Тут возникае вопрос - а как еффект видит предыдущее состояние, если уже есть новое? На этот вопросы мы ответили выше:

      Каждая функция "видит" переменные рендера, который ее определил

```js
useEffect(() => {
  const unsubscribe = api.subscribe(id, cb); // id 1 , 2 тд

  return () => {
    unsubscribe(id, cb); // id 1 , 2 тд
  };
});
```

Что бы не вполнять еффекты постоянно, можно передавать массив зависимостей вторым параметром, если оставить его пустым, еффект выполнится только 1 раз при монтировании компонента. Если внутри еффекта используются внешние переменные, нужно всегда передавать их в зависимости, что бы не было различных багов. В примере ниже title будет всегда первым именем и не важно, что само имя изменилось, еффект смотри не на имя, а на переданный массив зависимостей и пропускает выполнение колбека, если они не изменены.

Во втором примере мы снова обманули React и не передали зависимости, многие ожидают тут увидеть увеличение значения `count`, но этого не будет, потому что еффект запомнил результат первого рендера и каждую секунду будет выполнять действие `setCount(0 + 1)`, что бы решить проблему, досаточно передать колбек в `setCount`. Один из способов решить проблемы зависимостей - это использование хука `useReducer` (о нем поговорим ниже).

```js
useEffect(() => {
  document.title = name;
}, []);
```

```js
function Foo() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(count + 1);
      // setCount(state => state + 1); // передача колбека решит проблему
    }, 1000);
    return () => clearInterval(id);
  }, []);

  return <>{count}</>;
}
```

Распространенная ошибка думать, что функции не являются зависимостями. В примере еффект не сможет синхронизироавть текущее состояние и вызов функции, одно из решений - перенести обьявление функции в еффект, но все равно нам придется добавить `count` в еффект, иначе он просто не будет вызван.

```js
function Foo() {
  const [count, setCount] = useState(0);

  const foo = () => {
    console.log(count);
  };

  useEffect(() => {
    foo();
  }, []);

  return <>{count}</>;
}
```

Проблема решена? Нет, выше мы узнали, что на каждый рендер создаются новые функции, это значит, если `foo` - не зависит от состояния, она все равно будет пересоздаваться и еффект будет вызван по новой. Как этого избежать? Очень просто, достаточно обернуть функцию в хук `useCallback` (о нем поговорим ниже). useCallback - возвращает старую ссылку и React не выполняет еффект по новой. Но тут так же можно вынести функцию из компонента и передавать параметры через аргументы. (Этот вариант хорош, ели функция ничего не использует из области видимсости компонента).

```js
// const foo = (params) => {}; она будет создана только 1 раз

function Foo() {
  const [count, setCount] = useState(0);

  const foo = () => {};
  // const foo = useCallback(() => {}, []); // это работает !!

  useEffect(() => {
    foo();
  }, [foo]);

  return <>{count}</>;
}
```

Один из недостатков еффекта, как и работы в классах в целом - является состояние "гонки". Это значит, что я могу запустить еффект два раза с различными значениями и я не знаю, какой результат получу. Тесть при обновлении id - еффект будет запущен второй раз, но запросы выполняются с различной скоростью, результат второго вызова может прийти первым! Это не то, что мы желаем, ведь `count` будет соовершенно другим. Проблему можно решить самым простым флагом обновления. Еффект выполняет колбек "unmount", возвращаемый из него перед следующим рендером, значит предыдущий рузультат не будет записан в состояние.

```js
const Foo = ({ id }) => {
  const [count, setCount] = useState(0);

  useEffect(() => {
    async function fetchCount() {
      const data = await api.call(id);

      setState(data);
    }

    fetchCount();
  }, [id]);

  return <>{count}</>;
};

useEffect(() => {
  let isUpdate = false;

  async function fetchCount() {
    const data = await api.call(id);

    if (!isUpdate) {
      setState(data);
    }
  }

  fetchCount();

  return () => {
    isUpdate = true;
  };
}, [id]);
```

На последок хочу обратить внимание на `порядок` вызова еффектов. Приведем пример компонента:

```js
function App() {
  useEffect(() => {
    console.log("App useEffect");
  }, []);

  console.log("render DOM App");

  return (
    <div>
      <Children1 />
      <Children2 />
    </div>
  );
}

function Children1() {
  useEffect(() => {
    console.log("Children1 useEffect");
  }, []);

  console.log("render DOM Children1");

  return (
    <>
      <h1>Children1</h1>;
      <Children3 />
    </>
  );
}

function Children2() {
  useEffect(() => {
    console.log("Children2 useEffect");
  }, []);

  console.log("render DOM Children2");

  return (
    <>
      <h1>Children2</h1>;
    </>
  );
}

function Children3() {
  useEffect(() => {
    console.log("Children3 useEffect");
  }, []);

  console.log("render DOM Children3");

  return (
    <>
      <h1>Children3</h1>;
    </>
  );
}
```

Вы могли подумать, что результат рендера будет следующим, но это не так.

      render DOM App
      App useEffect

      render DOM Children1
      Children1 useEffect

      render DOM Children3
      Children3 useEffect

      render DOM Children2
      Children2 useEffect

Выше мы говорили о том, что еффект вызывается после того, как компонент примонтирован в DOM. Это значит, что компонент `App` не может быть примонтирован раньше, чем `Children1` и тд. (об этом поговорим ниже).
React вызывает компоненты сверху вниз, выполняя еффекты от ребенка к родителю, по завершению `работы` для текущей ноды (завершением работы для ноды считается тот момент, когда у него нет не обработанных дочерних елементов), а если у текущего компонента есть ребенок - он вызывает его и так до конца. (Все еффекты сохраняются в `Effect List`) План работы компонента выше:

- Выполнить render App (есть дочерний компонент), значит не вызываем еффект, идем к дочернему елементу.
- Выполнить render С1 (есть дочерний компонент), значит не вызываем еффект, идем к дочернему елементу.
- Выполнить render С3 (дочернего елемента нет), значит вызываем еффект.
  - Вернуться в C1 и проверить еще дочерние елементы, если нет - вызвать еффект.
- Выполнить render С2 (дочернего елемента нет), значит вызываем еффект.
  - вернуться к родителю App и выполнить его еффект.

Результат выполнения работы `С3 => C1 => C2 => App`.

Не знание этого может привести к багам.

```js
function App() {
  const [list, setList] = useState(null);

  useEffect(() => {
    setList([{ id: "App" }]);
  }, []);

  return (
    <div className="App">
      <Children list={list} setList={setList} />
    </div>
  );
}

const Children = ({ list, setList }) => {
  useEffect(() => {
    setList([{ id: "children" }]);
  }, [setList]);

  // ошибка !
  return (
    <>
      {list.map((item) => (
        <p>{item.id}</p>
      ))}
    </>
  );
};
```

В `Children` мы выводим `list`, но как узнали выше, еффект отработает асинхронно, значит при первом рендере мы будем мапить null, это можно исправить поставив проверку или передав массив как начальное состояние.
Второй момент в том, что в рендер попадет не `id - children`, а `id - app`, потому что еффекты выполняются от ребенка к родителю, об этом стоит не забывать.

### useLayoutEffect

Этот еффект обладает таким же API, как и `useEffect`, стем отличием, что он вызывается синхронно, после всех вычислений мутаций в DOM, тоесть блокирует отрисовку браузера, в то время как `useEffect` вызывается асинхронно и не блокирует рендер (это и есть основное различие - когда они срабатывают). Изменения, запланированные через useLayoutEffect, будут синхронно выполнены перед тем, как браузер получит возможность выполнить отрисовку. Колбек, которые возвращается из еффекта, вызывается так же как и в первом случае, но перед ним. Асинхронное поведение нужно для быстрого отклика приложения, потому что еффекту не нужно быть синхронным (есть редкие случаи, например чтение елементов DOM или синхронного повторного рендеринга).

Синхронный вызов значит, что `useLayoutEffect` будет выполнен раньше `useEffect`, это пригодится при работе с DOM (анимации, вычисление позиции, высоты). В примере ниже, при клике будет обновление дома, сначала 0, потом новое значение, но у нас не будет мигания, потому что еффект вызван синхронно, до того, как браузер успеет сделать рендер. Если заменить вызов на `useEffect`, то будет мигание [пример](https://codesandbox.io/s/useeffect-j083u?file=/src/App.js).

```js
const Foo = () => {
  const [value, setValue] = useState(0);

  useLayoutEffect(() => {
    if (!value) {
      setValue(Math.random() * 1000);
    }
  }, [value]);

  return <div onClick={() => setValue(0)}>{value}</div>;
};
```

### useCallback

```js
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
```

Хук возвращает мемоизированный колбек, это значит, что при каждом рендере, ссылка на функцию, будет не изменна. Ссылка будет новой в том случае, когда изменится одина из переданных зависимостей. Хук стоит использовать тогда, когда колбек передается `оптимизированным` дочерним копонентам (memo, pureComponent), которые проверяют равенство ссылок и не делают повторный рендер, стоит заметить, что без них - React произведет повторное обновление. Заблуждением является мысль о том, что хук быстрее,чем простое обьявления функции, это не так, потому что хук выполняется всегда на каждый рендер, помимо этого пераданная в него функция всегда новая и всегда сравнивает зависимости, что в итоге будет дороже, чем пересохдать функцию.

```js
const prevState = {
  callback: null,
  deps: null,
};

function useCallback(callback, deps) {
  if (!prevState.deps || !deps) {
    prevState.callback = callback;
    prevState.deps = deps;

    return callback;
  }

  if (shallowEqual(deps, prevState.deps)) {
    return prevState.callback;
  }

  prevState.callback = callback;
  prevState.deps = deps;

  return callback;
}
```

Минимальный пример реализации функции, она вызывается каждый рендер, в параметрах всегда приходит новая функция и зависимости, которые мы либо выбрасываем, либо обновляем состояние. Что бы не делать дишних вычислений, нужно понимать, когда хук использовать, а когда нет.

```js
const Messages = ({ messages }) => {
  const handleClick = (message) => {
    console.log(message.text);
  };

  return messages.map((message) => {
    return (
      <Message key={message.id} message={message} handleClick={handleClick} />
    );
  });
};
```

В примере на каждый рендер функция `handleClick` всегда будет новой, значит не важно, оптимизирован ли дочерний елемент, обновлятся будет весь список, что будет занимать время. Что бы не было лишних обновлений, достаточно обернуть обработчки в `useCallback`.

```js
const handleClick = useCallback((message) => {
  console.log(message.text);
}, []);
```

Когда обработчик используется без передачи дочернему елементу, нет смысла его выносить, потому что `useCallback` выполняет больше работы, чем обычное пересоздание функции.

```js
const Message = ({ handleClick }, message) => {
  const handleSelectMessage = (message) => handleClick(message);
  return <button onClick={handleSelectMessage}>{message.text}</button>;
};
```

### useMemo

```js
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

Хук принимает колбек и возвращает мемоизированное значение. `useMemo` довольно "дорогой" в исполнении и его так же не стоит использовать постоянно, он работает в два этапа:

- Маунт (mountMemo)
- Обновление (updateMemo)

Только после того, как отработает mountMemo, хук отдаст мемоизированное значение. Перед использованием хука нужно удостовериться, что будет выполняться довольно обьемное вычисление, если все причины рендера компонента указаны в мемо, то его использование так же будет лишним, потому что его функция и так будет вычисляться при каждом рендере.
Хук идентичен useCallback, с тем различием, что он сохраняет тело функции, а не саму функцию.

### useRef

useRef возвращает изменяемый ref-объект, свойство .current которого инициализируется переданным аргументом (initialValue). Возвращаемый объект будет сохраняться в течение всего времени жизни компонента. Хук создает обьект с изменяемым свойством `current`, в которое передается начальное значение, при каждом рендере ссылка на обьект будет одна и таже.

```js
const Foo = () => {
  const ref = useRef(value);

  useLayoutEffect(() => {
    const measure = ref.current.getBoundingClientRect();
    console.log(measure); // размер елемента и его позиция
  }, []);

  return <div ref={ref}>Body</div>;
};
```

Хук можно использовать различными способами, один из них - получение доступа к DOM елементам, React сам устанавливает нужное свойство в current на каждом узле. Он полезен при сохранении любого мутируемого значения, например предыдущего состояния.

```js
function usePrevious(value) {
  const ref = useRef();

  useEffect(() => {
    ref.current = value;
  }, [value]);

  return ref.current;
}
```

Каждый вызов `usePrevious` - мутирует свойство current, в примере получаем старое значение, потому что еффект выполняется после того, как предыдущее значение было получено из хука.

```js
function TextInputWithFocusButton() {
  const [name, setName] = useState("");

  const ref = useRef(null); // type HTMLInputElement

  const onButtonClick = () => {
    setName(nameRef.current.value);
  };
  return (
    <div>
      <p>{name}</p>

      <input ref={ref} type="text" />
      <button onClick={onButtonClick}>Задать имя</button>
    </div>
  );
}
```

Для каждого узла у реакта есть собственный тип, в примере можно использовать все методы инпута (click, focus, blur) - это может пригодиться для императивного доступа к элементам.

### useContext

```js
const value = useContext(Context);
```

Принимает объект контекста (значение, возвращённое из React.createContext) и возвращает текущее значение контекста для этого контекста. Текущее значение контекста определяется пропом value ближайшего `Context.Provider` над вызывающим компонентом в дереве. При обновлении ближайшего контекста - вызывается повторное обновление компонента, использующего этот хук. Хук не изменяет значение контекста, он толькопозволяет подписать компонент на контекст. `Provider` все еще нужен, для инициализации этого контекста.

Стандартный пример использования контекста с темой. `Provider` получает значение по умолчанию и передает его в контекст, его можно использовать в любом компоненте `ниже` по дереву (так же провайдер можно увидtть в инструментах разработчика). Что бы получить контекст на одном уровне с провайдером, нужно использовать `Consumer`. В `value` провайдера можно передавать любые значения или обработчики, которые потом можно использовать в дочерних компонентах. Контекст не стоит использовать в больших приложениях, для этого есть различные стейт менеджеры.

```js
const themes = {
  light: {
    foreground: "#000000",
    background: "#eeeeee",
  },
  dark: {
    foreground: "#ffffff",
    background: "#222222",
  },
};

const ThemeContext = React.createContext({ theme: themes.light });

function App() {
  const [theme, setTheme] = useState("light");
  const value = React.useContext(ThemeContext); // начальное состояние, если вызвать выше провайдера


  return (
    <ThemeContext.Provider value={{ theme: themes[theme], setTheme }}>
      <ThemeContext.Consumer>
        {(value) => {
          return <h1>Consumer</h1>;
        }}
      </ThemeContext.Consumer>
    </ThemeContext.Provider>
  );
  );
}

function Button() {
  const { theme, setTheme } = React.useContext(ThemeContext);

  return (
    <>
      <button onClock={() => setTheme("dark")} style={{ background: theme.background }}>dark</button>
      <button onClock={() => setTheme("light")} style={{ background: theme.background }}>light</button>
    </>
  )
}
```

Контекст нельз получить в текущемкомпоненте и выше, для этого можно использовать `Consumer`, который подписывается на изменения контекста. [пример](https://codesandbox.io/s/context-zkl8q?file=/src/App.js)

### useDebugValue

Нужен для использования в пользовательских хуках - отображает метку в `dev tools`, напротив хука, для более удобной отладки.

```js
function useAge() {
  const [age, setAge] = React.useState(0);

  useDebugValue(`age: ${age}`);

  return age;
}
```

### Пользовательские_хуки

Создание пользовательских хуков позволяет вам перенести логику компонентов в функции, которые можно повторно использовать. Пользовательский хук — это JavaScript-функция, имя которой начинается с «use», и которая может вызывать другие хуки (функция, которая не использует внутри React hooks - не является пользовательским хуком, даже если написана с приставкой "use").
Такие хуки не имеют одинаковой сигнатуры, мы сами решаем, что он должен вернуть, сделать, какие аргументы принимает, все как в обычных функциях. Каждый вызов пользовательского хука - получает изолированное состояние, как и каждый вызов обычного хука.

```js
const useMeasure = () => {
  const ref = React.useRef(null);
  const [state, setState] = React.useState({ width: 0, height: 0 });

  React.useLayoutEffect(() => {
    if (!ref.current) {
      return;
    }

    const { width, height } = ref.current.getBoundingClientRect();

    setState({
      width,
      height,
    });
  }, []);

  return [ref, state];
};
```

`useMeasure` - пользовательский хук, используется для того, что бы узнать размер элемента и его позицию, мы это можем сделать, потому что React сам установит свойство .current для конкретного узла

```js
const Foo = () => {
  const [ref, { width, height }] = useMeasure();

  return (
    <div ref={ref}>
      <h1>Пример использования хука useMeasure</h1>
      <p>Ширина {width}</p>
      <p>Высота {height}</p>
    </div>
  );
};
```

Что бы в каждом проекте не писать типовые хуки, есть библиотка [react-use](https://www.npmjs.com/package/react-use), в которой достаточно много разнообразных хуков и их описание.

### Хуки_изнутри

У хуков есть свои правила, которые показаны выше, почему же эти правила нужны?

Чтобы назначить поведение функциональному компоненту, нужно иметь возможность как-то ассоциировать это поведение с этим компонентом.

Каждый вызов хукаполагается на свой индекс (информация хранится в массивах) вызова между рендерингами. Это значит, что если поместить вызов в условие, то при последующих обновлениях, React не сможет определить, какой ответ возвращать хукам после условия, ведь все индексы, по которым оних хранил будут сдвинуты на один.

```js
const Foo = () => {
  const [age, setAge] = useState(0); // индекс 0
  const [name, setName] = useState(""); // индекс 1

  useEffect(() => {
    setName("Bogdan");
    setAge(23);
  });
};

/*
       useState() #1 State
Foo => useState() #2 State
       useEffect() #3 useEffect

*/
```

Как выше говорили, React хранит состояние вне функции, поэтому после каждого рендера оно не теряется, кроме того, этот код не доступен другим компонентам, но он есть в пространстве текущего компонента. Для примера назовем setState - сеттер, а состояние state. [пример](https://codesandbox.io/s/immutable-morning-cndrg?file=/src/index.js) Реализацию можно представить ввиде двух массивов - state, setters. Каждый вызов хука React по его id - сохраняет в массив, к конкретной `fiber ноде`, при каждом обновлении этот индекс сбрасывается, при каждом вызове хука - увеличивается. Поэтому если вызвать хук по условию - это приведет к ошибке, ведь React не знает, что не нужно увеличивать счетчик и вернет не верный ответ.
